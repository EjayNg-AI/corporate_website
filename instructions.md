The theme files are found in ./corporate-theme

1. The attribute “shouldSyncIcon” that appears in several site-logo blocks was experimental and has already been removed from WordPress core. The block parser now treats it as an unknown attribute; when the Site Editor opens it will flag the Site Logo blocks as “modified” or “needs conversion”, and on saving it will silently strip the attribute. Users will see an annoying “This block contains unexpected content” message and may lose unsaved changes. Fixing it is simple – edit every occurrence of the site-logo block JSON and delete the fragment `"shouldSyncIcon":false`. After that the Site Logo block will again be recognised as valid and no warning will appear.

2. Each page template inserts the header template-part with `tagName:"header"`, and the template-part itself starts with a normal Group block that renders a `<div class="header">…</div>`. The outcome in the DOM is `<header><div class="header">…</div></header>`. This double wrapping is legal HTML, but CSS or JS that targets `.header` while assuming it is the outermost element may fail and accessibility tools can complain about redundant landmarks. There are two ways to rectify the structure: keep the tag on the Group that lives inside the part and remove `tagName:"header"` from every `<wp:template-part>` call, or keep `tagName:"header"` on the template-part call and change the first Group inside header.html so that it also uses `tagName":"div"` (or omit the attribute and let it render as `<div>`).

3. `add_theme_support( 'editor-styles' )` is enabled in functions.php but no stylesheet is ever enqueued for the editor. That means the back-end does not inherit the custom colour variables or layout rules defined in style.css and theme.json, so blocks can look correct on the front-end but appear broken or unreadable while building pages. The remedy is to load a sheet in the editor; the common one-liner is `add_editor_style( 'style.css' );`. Place it inside the existing `corporate_theme_setup()` function just after the call to add_theme_support( 'editor-styles' ).

4. To offset the sticky header when the WordPress admin-bar is visible the theme attaches inline CSS to the core style handle `wp-block-library`. If a future WordPress version renames that handle, or if a performance plugin dequeues it, the inline rule will not be printed and the header will slide under the admin bar, hiding part of the page. A robust solution is to create and enqueue a small empty stylesheet of your own, for instance `wp_register_style( 'corporate-fixes', false ); wp_enqueue_style( 'corporate-fixes' );` and then attach the inline rule to that handle with `wp_add_inline_style( 'corporate-fixes', '/* css */' );`. Your code will then survive any upstream change in core.

5. The theme declares editor and front-end spacing variables through theme.json, yet a few templates hard-code large pixel values for headings (`font-size":"8rem"` in templates/404.html for example). When the responsive fluid-typography engine scales these values the hard coded numbers do not change, so on small screens headings may overflow or introduce horizontal scrolling. Replace the fixed number with the design system’s custom size token, e.g. `fontSize":"xx-large"` or set it to a clamp-based value in theme.json and reference that preset in the block markup (`fontSize":"huge"`). The content will then scale consistently in both editor and front-end.

6. The JavaScript that toggles dark-mode queries for the button with `document.querySelector('.theme-toggle')`. In the header template that element is placed inside a `wp:html` block. When users open the header in the Site Editor any edit that regenerates the HTML block (e.g. changing the button label) will strip the class or the attributes unless the raw HTML is manually preserved, leading to a non-functional toggle in production. The safer fix is to rebuild the toggle as a proper Gutenberg Button block (or a Navigation Toggle variant) and hook your script to that block’s unique selector, or make the script fall back to `document.querySelector('[data-theme-toggle]')` and then store only that custom data attribute inside the raw HTML so editors are less likely to delete it.
